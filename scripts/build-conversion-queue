#!/bin/bash
# =============================================================================
# Build Conversion Queue
# =============================================================================
# Builds a list of audiobooks that need conversion by comparing source ASINs
# against already-converted ASINs (from chapters.json metadata).
#
# Output: List of .aaxc files whose ASINs are not yet in the library
# Usage: build-conversion-queue [--rebuild] [--verbose]
# =============================================================================

set -euo pipefail

# Load configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [[ -f "${SCRIPT_DIR}/../lib/audiobooks-config.sh" ]]; then
    source "${SCRIPT_DIR}/../lib/audiobooks-config.sh"
elif [[ -f "/opt/audiobooks/lib/audiobooks-config.sh" ]]; then
    source "/opt/audiobooks/lib/audiobooks-config.sh"
elif [[ -f "/usr/local/lib/audiobooks/audiobooks-config.sh" ]]; then
    source "/usr/local/lib/audiobooks/audiobooks-config.sh"
fi

# Configuration
SOURCES_DIR="${AUDIOBOOKS_SOURCES:-/raid0/Audiobooks/Sources}"
LIBRARY_DIR="${AUDIOBOOKS_LIBRARY:-/raid0/Audiobooks/Library}"
STAGING_DIR="${AUDIOBOOKS_STAGING:-/tmp/audiobook-staging}"
INDEX_DIR="${AUDIOBOOKS_DATA:-/raid0/Audiobooks}/.index"
VERBOSE=false
REBUILD=false
QUICK_UPDATE=false
QUICK_SOURCE=""
QUICK_OUTPUT=""

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --rebuild) REBUILD=true; shift ;;
        --verbose|-v) VERBOSE=true; shift ;;
        --quick-update)
            # Quick update mode: --quick-update SOURCE_AAXC OUTPUT_OPUS
            QUICK_UPDATE=true
            shift
            QUICK_SOURCE="${1:-}"
            shift
            QUICK_OUTPUT="${1:-}"
            shift
            ;;
        *) shift ;;
    esac
done

mkdir -p "$INDEX_DIR"

log() {
    $VERBOSE && echo "[$(date '+%H:%M:%S')] $1" >&2
}

# Normalize a title for comparison
# Removes common suffixes, punctuation, collapses spaces, lowercases
normalize_title() {
    local input="$1"
    echo "$input" |
        # Remove common audiobook suffixes (case insensitive via later lowercase)
        sed -E 's/[[:space:]]*\([Uu]nabridged\)//g' |
        sed -E 's/[[:space:]]*\([Aa]bridged\)//g' |
        sed -E 's/[[:space:]]+[Aa][[:space:]]+[Nn]ovel[[:space:]]*$//g' |
        sed -E 's/[[:space:]]+[Aa][[:space:]]+[Mm]emoir[[:space:]]*$//g' |
        # Convert underscores to spaces
        tr '_' ' ' |
        # Convert hyphens to spaces
        tr -- '-' ' ' |
        # Transliterate accented characters to ASCII equivalents
        iconv -f UTF-8 -t ASCII//TRANSLIT 2>/dev/null |
        # Remove punctuation except spaces
        tr -cd '[:alnum:] ' |
        # Collapse multiple spaces
        tr -s ' ' |
        # Lowercase
        tr '[:upper:]' '[:lower:]' |
        # Remove leading articles (the, a, an)
        sed -E 's/^(the|a|an) //' |
        # Trim whitespace
        sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
}

# Extract ASIN from source filename
# Filenames are like: B002UZJTXM_Title_Here-AAX_22_64.aaxc
extract_asin() {
    local file="$1"
    local bn=$(basename "$file" .aaxc)
    # ASIN is the first 10 alphanumeric chars before underscore
    if [[ "$bn" =~ ^([A-Z0-9]{10})_ ]]; then
        echo "${BASH_REMATCH[1]}"
    else
        # Non-ASIN file (e.g., direct download without ASIN prefix)
        echo ""
    fi
}

# Extract ASIN from chapters.json file
# Returns ASIN if found, empty string otherwise
extract_asin_from_chapters() {
    local chapters_file="$1"
    grep -o '"asin": *"[^"]*"' "$chapters_file" 2>/dev/null | head -1 | sed 's/.*"\([^"]*\)"$/\1/'
}

# Build converted ASIN index from library chapters.json files
build_converted_asin_index() {
    log "Building converted ASIN index..."
    local index_file="$INDEX_DIR/converted_asins.idx"
    local temp_file="$INDEX_DIR/converted_asins.idx.tmp"

    > "$temp_file"

    local count=0
    # Scan library for chapters.json files (contain ASIN metadata)
    while IFS= read -r chapters_file; do
        local asin=$(extract_asin_from_chapters "$chapters_file")
        if [[ -n "$asin" ]]; then
            echo "$asin" >> "$temp_file"
            count=$((count + 1))
        fi
    done < <(find "$LIBRARY_DIR" -name "*-chapters.json" -type f 2>/dev/null)

    # Also scan staging
    while IFS= read -r chapters_file; do
        local asin=$(extract_asin_from_chapters "$chapters_file")
        if [[ -n "$asin" ]]; then
            echo "$asin" >> "$temp_file"
            count=$((count + 1))
        fi
    done < <(find "$STAGING_DIR" -name "*-chapters.json" -type f 2>/dev/null)

    # Sort and deduplicate
    sort -u "$temp_file" > "$index_file"
    rm -f "$temp_file"

    local unique_count=$(wc -l < "$index_file")
    log "Converted ASIN index: $unique_count unique ASINs"
}

# Build source ASIN index
build_source_asin_index() {
    log "Building source ASIN index..."
    local index_file="$INDEX_DIR/source_asins.idx"
    local temp_file="$INDEX_DIR/source_asins.idx.tmp"

    > "$temp_file"

    local count=0
    while IFS= read -r aaxc_file; do
        local asin=$(extract_asin "$aaxc_file")
        if [[ -n "$asin" ]]; then
            echo "${asin}|${aaxc_file}" >> "$temp_file"
            count=$((count + 1))
        else
            # Non-ASIN file - use filename hash as identifier
            local bn=$(basename "$aaxc_file" .aaxc)
            echo "NOASIN_${bn}|${aaxc_file}" >> "$temp_file"
            count=$((count + 1))
        fi
    done < <(find "$SOURCES_DIR" -maxdepth 1 -name "*.aaxc" -type f 2>/dev/null | sort)

    sort "$temp_file" > "$index_file"
    rm -f "$temp_file"

    log "Source ASIN index: $count files"
}

# Build converted index: normalized_title (from both library and staging)
# Uses opus filenames which ARE the metadata titles (AAXtoMP3 renames output)
build_converted_index() {
    log "Building converted index..."
    local index_file="$INDEX_DIR/converted.idx"
    local temp_file="$INDEX_DIR/converted.idx.tmp"
    local bn normalized

    > "$temp_file"

    # Index library files (opus filename = metadata title from conversion)
    while read -r opus_file; do
        bn=$(basename "$opus_file" .opus)
        normalized=$(normalize_title "$bn")
        echo "$normalized" >> "$temp_file"
    done < <(find "$LIBRARY_DIR" -name "*.opus" -type f ! -name "*.cover.opus" 2>/dev/null)

    # Index staging files
    while read -r opus_file; do
        bn=$(basename "$opus_file" .opus)
        normalized=$(normalize_title "$bn")
        echo "$normalized" >> "$temp_file"
    done < <(find "$STAGING_DIR" -name "*.opus" -type f ! -name "*.cover.opus" 2>/dev/null)

    # Sort and deduplicate
    sort -u "$temp_file" > "$index_file"
    rm -f "$temp_file"

    local count=$(wc -l < "$index_file")
    log "Converted index: $count unique titles"
}

# Extract first N significant words from a title (for fuzzy matching)
get_title_prefix() {
    local title="$1"
    local word_count="${2:-3}"
    echo "$title" | awk -v n="$word_count" '{for(i=1;i<=n && i<=NF;i++) printf "%s ", $i; print ""}' | sed 's/ *$//'
}

# Count words in common between two titles (excluding common articles)
words_in_common() {
    local title1="$1"
    local title2="$2"
    local count=0
    # Convert to arrays, excluding short words (articles)
    for word in $title1; do
        if [[ ${#word} -ge 3 ]] && [[ " $title2 " == *" $word "* ]]; then
            count=$((count + 1))
        fi
    done
    echo "$count"
}

# Get first significant word (4+ chars) from title
get_first_significant_word() {
    local title="$1"
    for word in $title; do
        if [[ ${#word} -ge 4 ]]; then
            echo "$word"
            return
        fi
    done
    # Fallback to first word if none are 4+ chars
    echo "${title%% *}"
}

# Check if a title is already converted using EXACT matching only
# Different ASINs = different books, even with same title
# Returns 0 (true) if converted, 1 (false) if not
is_title_converted() {
    local source_title="$1"
    local converted_idx="$2"

    # EXACT match only - no fuzzy/prefix matching
    # This ensures different editions (ASINs) are treated as separate books
    if grep -qFx "$source_title" "$converted_idx" 2>/dev/null; then
        return 0
    fi

    return 1
}

# Find the matching converted title for a source title
# Returns the matched title (for exact or prefix match), or empty if no match
# Prefix matching: "catching fire" matches "catching fire the hunger games"
find_matching_converted() {
    local source_title="$1"
    local converted_idx="$2"

    # Exact match first
    if grep -qFx "$source_title" "$converted_idx" 2>/dev/null; then
        echo "$source_title"
        return
    fi

    # Prefix match: source is longer than converted (source has subtitle)
    # e.g., source "catching fire the hunger games book 2" matches "catching fire"
    while IFS= read -r conv_title; do
        if [[ "$source_title" == "$conv_title"* ]]; then
            echo "$conv_title"
            return
        fi
    done < "$converted_idx"

    # Prefix match: converted is longer than source (rare but possible)
    while IFS= read -r conv_title; do
        if [[ "$conv_title" == "$source_title"* ]]; then
            echo "$conv_title"
            return
        fi
    done < "$converted_idx"
}

# Extract title from source filename (for fallback matching)
get_filename_title() {
    local file="$1"
    local bn=$(basename "$file")
    bn="${bn%.aaxc}"
    bn="${bn%.m4b}"
    # Remove ASIN prefix (e.g., B002UZJTXM_) and AAX suffix (e.g., -AAX_22_64)
    echo "$bn" | sed -E 's/^[A-Z0-9]{10}_//' | sed -E 's/-AAX_[0-9]+_[0-9]+$//' | tr '_' ' '
}

# Find files needing conversion using hybrid ASIN + title matching
# Strategy:
# 1. Try ASIN match first (most accurate)
# 2. If no ASIN match, fall back to title matching (for older library entries without ASIN metadata)
# 3. Non-ASIN files always use title matching
build_queue() {
    log "Building conversion queue..."
    local queue_file="$INDEX_DIR/queue.txt"
    local source_asin_idx="$INDEX_DIR/source_asins.idx"
    local converted_asin_idx="$INDEX_DIR/converted_asins.idx"
    local converted_title_idx="$INDEX_DIR/converted.idx"

    > "$queue_file"

    local checked=0
    local queued=0
    local matched_asin=0
    local matched_title=0

    while IFS='|' read -r asin_or_id path; do
        checked=$((checked + 1))

        if [[ "$asin_or_id" == NOASIN_* ]]; then
            # Non-ASIN file: use title matching with prefix support
            local title="${asin_or_id#NOASIN_}"
            # Remove AAX suffix and convert underscores to spaces
            title=$(echo "$title" | sed -E 's/-AAX_[0-9]+_[0-9]+$//' | tr '_' ' ')
            local normalized=$(normalize_title "$title")

            # Try exact match first
            if grep -qFx "$normalized" "$converted_title_idx" 2>/dev/null; then
                matched_title=$((matched_title + 1))
                log "  Title match (no ASIN): $normalized"
            # Try prefix match: source is shorter
            elif grep -q "^${normalized} " "$converted_title_idx" 2>/dev/null; then
                matched_title=$((matched_title + 1))
                log "  Prefix match (no ASIN): $normalized"
            # Try prefix match: source is longer
            elif grep -q "^${normalized%% *}" "$converted_title_idx" 2>/dev/null; then
                local found=false
                while IFS= read -r conv_title; do
                    if [[ "$normalized" == "$conv_title"* ]]; then
                        matched_title=$((matched_title + 1))
                        log "  Prefix match (no ASIN, source longer): $normalized"
                        found=true
                        break
                    fi
                done < <(grep "^${normalized%% *}" "$converted_title_idx")
                # Try N-word prefix match
                if ! $found; then
                    local src_prefix=$(get_title_prefix "$normalized" 3)
                    while IFS= read -r conv_title; do
                        local conv_prefix=$(get_title_prefix "$conv_title" 3)
                        if [[ "$src_prefix" == "$conv_prefix" ]]; then
                            matched_title=$((matched_title + 1))
                            log "  3-word prefix match (no ASIN): $src_prefix"
                            found=true
                            break
                        fi
                    done < <(grep "^${normalized%% *}" "$converted_title_idx")
                fi
                # Try 2-word prefix match as last resort
                if ! $found; then
                    local src_prefix2=$(get_title_prefix "$normalized" 2)
                    while IFS= read -r conv_title; do
                        local conv_prefix2=$(get_title_prefix "$conv_title" 2)
                        if [[ "$src_prefix2" == "$conv_prefix2" ]]; then
                            matched_title=$((matched_title + 1))
                            log "  2-word prefix match (no ASIN): $src_prefix2"
                            found=true
                            break
                        fi
                    done < <(grep "^${normalized%% *}" "$converted_title_idx")
                fi
                if ! $found; then
                    echo "$path" >> "$queue_file"
                    queued=$((queued + 1))
                    log "  Need conversion (no ASIN): $title"
                fi
            else
                echo "$path" >> "$queue_file"
                queued=$((queued + 1))
                log "  Need conversion (no ASIN): $title"
            fi
        else
            # ASIN file: try ASIN match first
            if grep -qFx "$asin_or_id" "$converted_asin_idx" 2>/dev/null; then
                matched_asin=$((matched_asin + 1))
                log "  ASIN match: $asin_or_id"
            else
                # No ASIN match - fall back to title matching
                # (for older library entries that don't have chapters.json with ASIN)
                local title=$(get_filename_title "$path")
                local normalized=$(normalize_title "$title")

                # Try exact match first
                if grep -qFx "$normalized" "$converted_title_idx" 2>/dev/null; then
                    matched_title=$((matched_title + 1))
                    log "  Title match (ASIN $asin_or_id not in index): $normalized"
                # Try prefix match: source is shorter (e.g., "The Black Box" matches "The Black Box Harry Bosch Book 16")
                elif grep -q "^${normalized} " "$converted_title_idx" 2>/dev/null; then
                    matched_title=$((matched_title + 1))
                    log "  Prefix match (ASIN $asin_or_id not in index): $normalized"
                # Try prefix match: source is longer (source has subtitle)
                elif grep -q "^${normalized%% *}" "$converted_title_idx" 2>/dev/null; then
                    # Check if any converted title is a prefix of our source
                    local found=false
                    while IFS= read -r conv_title; do
                        if [[ "$normalized" == "$conv_title"* ]]; then
                            matched_title=$((matched_title + 1))
                            log "  Prefix match (source longer): $normalized matches $conv_title"
                            found=true
                            break
                        fi
                    done < <(grep "^${normalized%% *}" "$converted_title_idx")
                    # Try N-word prefix match (e.g., "dark tower i volume 1" matches "dark tower i the gunslinger")
                    if ! $found; then
                        local src_prefix=$(get_title_prefix "$normalized" 3)
                        while IFS= read -r conv_title; do
                            local conv_prefix=$(get_title_prefix "$conv_title" 3)
                            if [[ "$src_prefix" == "$conv_prefix" ]]; then
                                matched_title=$((matched_title + 1))
                                log "  3-word prefix match: $src_prefix"
                                found=true
                                break
                            fi
                        done < <(grep "^${normalized%% *}" "$converted_title_idx")
                    fi
                    # Try 2-word prefix match as last resort (e.g., "blue belle burke" matches "blue belle a burke")
                    if ! $found; then
                        local src_prefix2=$(get_title_prefix "$normalized" 2)
                        while IFS= read -r conv_title; do
                            local conv_prefix2=$(get_title_prefix "$conv_title" 2)
                            if [[ "$src_prefix2" == "$conv_prefix2" ]]; then
                                matched_title=$((matched_title + 1))
                                log "  2-word prefix match: $src_prefix2"
                                found=true
                                break
                            fi
                        done < <(grep "^${normalized%% *}" "$converted_title_idx")
                    fi
                    if ! $found; then
                        echo "$path" >> "$queue_file"
                        queued=$((queued + 1))
                        log "  Need conversion: ASIN $asin_or_id ($normalized)"
                    fi
                else
                    echo "$path" >> "$queue_file"
                    queued=$((queued + 1))
                    log "  Need conversion: ASIN $asin_or_id ($normalized)"
                fi
            fi
        fi

        # Progress every 100 files
        if $VERBOSE && (( checked % 100 == 0 )); then
            log "  Checked $checked sources..."
        fi
    done < "$source_asin_idx"

    log "Queue: $queued files need conversion"
    log "  Matched by ASIN: $matched_asin"
    log "  Matched by title (fallback): $matched_title"
    log "  Total checked: $checked"
    echo "$queued"
}

# Check if indexes are stale (source dir modified after index)
indexes_current() {
    local source_asin_idx="$INDEX_DIR/source_asins.idx"
    local converted_asin_idx="$INDEX_DIR/converted_asins.idx"
    local converted_title_idx="$INDEX_DIR/converted.idx"

    # All three indexes must exist
    [[ -f "$source_asin_idx" ]] && [[ -f "$converted_asin_idx" ]] && [[ -f "$converted_title_idx" ]] || return 1

    # Check if any new aaxc files are newer than the source index
    local newest_source=$(find "$SOURCES_DIR" -maxdepth 1 -name "*.aaxc" -type f -newer "$source_asin_idx" 2>/dev/null | head -1)
    [[ -z "$newest_source" ]] || return 1

    # Check if any new chapters.json files are newer than the converted ASIN index
    local newest_chapters=$(find "$LIBRARY_DIR" -name "*-chapters.json" -type f -newer "$converted_asin_idx" 2>/dev/null | head -1)
    [[ -z "$newest_chapters" ]] || return 1

    # Check staging too
    local newest_staging=$(find "$STAGING_DIR" -name "*-chapters.json" -type f -newer "$converted_asin_idx" 2>/dev/null | head -1)
    [[ -z "$newest_staging" ]] || return 1

    return 0
}

# Quick update indexes after a single file conversion
# Usage: quick_update_indexes SOURCE_AAXC OUTPUT_OPUS
# Thread-safe using flock for concurrent updates from parallel processes
quick_update_indexes() {
    local source_file="$1"
    local output_file="$2"
    local lock_file="$INDEX_DIR/.index.lock"
    local queue_file="$INDEX_DIR/queue.txt"
    local converted_idx="$INDEX_DIR/converted.idx"
    local converted_asin_idx="$INDEX_DIR/converted_asins.idx"

    # Validate inputs
    [[ -n "$source_file" ]] || { echo "ERROR: Source file required" >&2; return 1; }
    [[ -n "$output_file" ]] || { echo "ERROR: Output file required" >&2; return 1; }

    # Get output directory (where chapters.json might be)
    local output_dir=$(dirname "$output_file")
    local output_basename=$(basename "$output_file" .opus)

    # Normalize the output title for converted.idx
    local normalized_title=$(normalize_title "$output_basename")

    # Extract ASIN from source filename
    local source_asin=$(extract_asin "$source_file")

    # Try to get ASIN from chapters.json if it exists
    local chapters_file=""
    local chapters_asin=""
    for cf in "$output_dir"/*-chapters.json; do
        if [[ -f "$cf" ]]; then
            chapters_file="$cf"
            chapters_asin=$(extract_asin_from_chapters "$cf")
            break
        fi
    done

    # Use source ASIN if chapters.json doesn't have one
    local asin="${chapters_asin:-$source_asin}"

    # Acquire exclusive lock for atomic updates
    (
        flock -x 200

        # 1. Remove source file from queue.txt (if present)
        if [[ -f "$queue_file" ]]; then
            # Use grep -v with fixed string matching for exact path removal
            grep -vF "$source_file" "$queue_file" > "$queue_file.tmp" 2>/dev/null || true
            mv "$queue_file.tmp" "$queue_file"
        fi

        # 2. Add normalized title to converted.idx (if not already present)
        if [[ -f "$converted_idx" ]]; then
            if ! grep -qxF "$normalized_title" "$converted_idx" 2>/dev/null; then
                echo "$normalized_title" >> "$converted_idx"
                # Keep sorted for binary search compatibility
                sort -u "$converted_idx" -o "$converted_idx"
            fi
        else
            echo "$normalized_title" > "$converted_idx"
        fi

        # 3. Add ASIN to converted_asins.idx (if present and not already there)
        if [[ -n "$asin" ]] && [[ "$asin" != NOASIN_* ]]; then
            if [[ -f "$converted_asin_idx" ]]; then
                if ! grep -qxF "$asin" "$converted_asin_idx" 2>/dev/null; then
                    echo "$asin" >> "$converted_asin_idx"
                    sort -u "$converted_asin_idx" -o "$converted_asin_idx"
                fi
            else
                echo "$asin" > "$converted_asin_idx"
            fi
        fi

    ) 200>"$lock_file"

    log "Updated indexes: removed '$source_file', added '$normalized_title'${asin:+ (ASIN: $asin)}"
    return 0
}

# Main
main() {
    # Handle quick-update mode (called after each individual conversion)
    if $QUICK_UPDATE; then
        quick_update_indexes "$QUICK_SOURCE" "$QUICK_OUTPUT"
        exit $?
    fi
    if $REBUILD || ! indexes_current; then
        log "Rebuilding indexes..."
        build_source_asin_index
        build_converted_asin_index
        build_converted_index  # Still needed for non-ASIN fallback
    else
        log "Indexes are current"
    fi

    local queue_count=$(build_queue)
    local queue_file="$INDEX_DIR/queue.txt"

    if [[ "$queue_count" -eq 0 ]]; then
        echo "No files need conversion" >&2
        exit 0
    fi

    # Output the queue (for piping to parallel)
    cat "$queue_file"
}

main "$@"
